# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/10_simulation.ipynb (unless otherwise specified).

__all__ = ['generate_cell', 'generate_cells']

# Cell
import os
import numpy as np
import pandas as pd
import scipy

from .config import *
from .loglike import *
from .exposure import *
from .lightcurve import *

# Cell
class _Sampler():
    """ Sample an arbitrary function or histogram

    - func -- the function, or a histogram
    - a,b  -- limits (default 0,1)
    - n    -- table size (ignored if a histogram)

    Note the property `mean` is the expected mean.
    """

    def __init__(self, func, limits=(0,1), n=100):

        a,b = limits
        self.x = np.linspace(a,b,n+1) # bin edges
        dx = (b-a)/(n)/2

        if not hasattr(func, '__len__'):
            # evaluate at bin centers
            y = [func(t-dx) for t in self.x]
        else:
            n = len(func)
            self.x = np.linspace(a,b,n)
            y = func
        cy = np.cumsum(y)
        d = cy[-1]-cy[0]
        self.sy = (cy-cy[0])/d

        self.mean = np.sum( (self.x-dx) * y) / d

    def _evaluate(self, r):
        """evaluate inverse integral. expect 0<r<1 """
        return np.interp(r, self.sy, self.x)

    def __call__(self, size):
        """Generate `size` values
        """
        from scipy.stats import uniform
        return self._evaluate(uniform.rvs(size=size))

# Cell
class _WeightGenerator(_Sampler):
    """Generate a set of weights

    - `func` -- nominal weight distribution function, evaluated on (0,1)
    - `alpha, beta` -- (default 0,0). Values for $\\alpha$, $\\beta$.

    """
    def __init__(self, func, alpha=0, beta=0, n=100):
        if alpha==0 and beta==0:
            fprime = func
        else:
            # weight the function
            fprime = lambda w: func(w) * ( 1 + alpha*w + beta*(1-w) )
        super().__init__( fprime, limits=(0,1),  n=n)


# Cell
def generate_cell(wfun, mu, alpha=0, beta=0):
    """ Generate a cell

    - `wfun` -- weight function, or histogram.
        Defined on (0,1)
    - `mu` -- number of expected weights, on average
    - `alpha`, `beta`  -- default 0,0; values for $\\alpha$ and  $\\beta$ for this cell

    Returns a dict with:
    - `n` -- actual generated number of weights, from Poisson
    - `w` -- array of weights
    - `S, B` -- expected values for $\sum w$ and $\sum(1-w)$, calulated from wfun
    """
    from scipy import stats

    wgen_nominal = _WeightGenerator(wfun)
    wgen_cell =wgen_nominal if alpha==0 and beta==0 else _WeightGenerator(wfun, alpha, beta)

    # adjust expected number of events:
    wbar = wgen_nominal.mean
    mu_cell = mu * (1+alpha*wbar+beta*(1-wbar))

    # the weight array
    n = stats.poisson.rvs(mu_cell )
    w = wgen_cell(n)

    S = wgen_nominal.mean * mu
    B = mu-S

    return dict(
        n=n,
        w=np.array(w, np.float32), #np.uint8),
        S=S,
        B=B,
    )

# Cell
def generate_cells(config, source, wfun, source_flux):
    """

    - `source` -- a PointSource object, use to get exposure at its position
    - `wfun`   -- a weight function or histogram
    - `flux_fun` -- function of MJD time for the counts/day

    """
    fexp, bins = get_binned_exposure(config, source)

    cells=[]
    for i, e in enumerate(fexp):
        a,b = bins[i:i+2]
        t, tw = (a+b)/2, b-a
        mu = source_flux(t)*tw *e

        cell = dict(t=t, tw=tw, e=e)
        cell.update(generate_cell(wfun, mu))

        cells.append(cell)
    return pd.DataFrame(cells)