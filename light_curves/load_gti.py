# AUTOGENERATED! DO NOT EDIT! File to edit: 02_load_gti.ipynb (unless otherwise specified).

__all__ = ['get_gti']

# Cell
from astropy.io import fits
import numpy as np
import pandas as pd

from .config import MJD

def get_gti(config, gti_files):
    """Combine the GTI intervals that fall within the gti range
    Return a function that tests a list of times
    """
    if config.verbose>1:
        print(f'Processing {len(gti_files)} GTI files ... ', end='')
    starts=[]
    stops=[]
    for i, ft1 in enumerate(gti_files):
        with fits.open(ft1) as hdu:
            gti_data = hdu['GTI'].data
            start = gti_data.START
            if i>0:
                assert start[0]>= stops[-1][-1], f'file {ft1} has start time not following preceding file'
            starts.append(start)
            stops.append( gti_data.STOP)
    start = MJD(np.concatenate(starts))
    stop  = MJD(np.concatenate(stops))

    if config.verbose>1:
        livetime = (stop-start).sum()
        print( f' {len(gti_files)} files, {len(start)} intervals with'\
               f' {int(livetime):,} days live time')

    sel = slice(None)
    if config.mjd_range is not None:
        a,b =  np.searchsorted(start, config.mjd_range)
        if a>0 or b<len(start):
            if config.verbose>1:
                print(f'\tcut from {len(start):,} to {a} - {b}, or {b-a:,} entries after MJD range selection')
            sel = slice(a,b)


    class GTI(object):
        """ functor class that tests for being in the GTI range
        """
        def __init__(config, start, stop):
            # prepare single merged array with even, odd entries start and stop
            a,b =start, stop
            config.fraction = np.sum(b-a)/(b[-1]-a[0])
            assert len(a)==len(b)
            config.g = np.array([a,b]).T.flatten()
            assert np.sum(np.diff(config.g)<0)==0, 'Bad GTI ordering'

        def __call__(config, time):
            # use digitize to find if in good/bad interval by odd/even
            x = np.digitize(time, config.g)
            return np.bitwise_and(x,1).astype(bool)

        def __repr__(config):
            return  f'{config.__class__.__name__} MJD range: {config.g[0]:.2f}-{config.g[-1]:.2f}'\
                    f', good fraction {config.fraction:.2f} '

    gti =  GTI(start[sel],stop[sel])
    if config.verbose>1:
        print(f'\t{gti}')
    return gti